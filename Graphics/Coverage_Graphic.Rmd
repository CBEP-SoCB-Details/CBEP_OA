---
title: "Data Coverage Graphic"
author: Curtis C. Bohlen
output:
  github_document:
    toc: true
    fig_width: 7
    fig_height: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Load Libraries
```{r load_libraries}
library(tidyverse)
library(readr)

library(CBEPgraphics)

load_cbep_fonts()
```

# Load Data
## Establish Folder References
```{r folder_refs}
sibfldnm <- 'Derived_Data'
parent   <- dirname(getwd())
sibling  <- file.path(parent,sibfldnm)

fn    <- 'CascoBayOAData.csv'
fpath <- file.path(sibling,fn)
```


## Load The Data
The following loads existing data, including a "Temperature Adjusted" pCO2 value based on Takehashi et al. 2002. It then collapses that data to daily summaries. 

```{r load_data} 
all_data <- read_csv(fpath,
                     col_types = cols(dd = col_integer(), 
                                      doy = col_integer(),
                                      hh = col_integer(),
                                      mm = col_integer(),
                                      yyyy = col_integer())) %>%
  select(c(13, 1:4, 14, 5:6, 8, 7 ,16, 9:12))
```

# Data Coverage Chart
## Organize Data

By default, ggplot connects all points in sequence with geom_line().  In this context, that would incorrectly draw lines through periods of time where data is unavailable.  The function geom_line can accept a "group" aesthetic, which tells it to draw lines between points within groups only. (Color aesthetics work similarly).  So, we need to create a dataframe in which we give contiguous groups of dates the same grop signifier, and pass that to ggplot.

```{r data_organization}
coverage <- all_data %>%
  mutate_at(7:13, ~! is.na(.)) %>%
  select(1:13) %>%
  gather(key = Parameter,  value =  Availability, 7:13, factor_key = FALSE) %>%
  filter(Availability)

dif <- c(1,diff(coverage$datetime, units = hours))  # Calculate first differences
d2 <- c(1, which(dif != 1), nrow(coverage)+1)       # Find indexes to all spots where the first difference is not one
                                                    # This produces a list of indexes to first observations after
                                                    # gaps in the data (or changes in which variable we are looking at).
coverage$grp <- rep(1:length(diff(d2)), diff(d2))   # diff(d2) here is the number of observations in each
                                                    # contiguous block of observations.  We assign each  group
                                                    # a number between 1 and the number of groups, and then
                                                    # assign every observation in that block that number as its
                                                    # group signifier.
```

## Draft Coverage Chart
```{r draft_chart, fig.height=3, fig.width = 8}
labs <- c('Temperature', 'Salinity', 'Dissolved Oxygen', 'pCO2', 'pH', 'Omega')
plt<- coverage %>%
  filter(Parameter != 'co2_corr') %>%
  mutate(Parameter = factor(Parameter,
                            levels = c('temp', 'sal', 'do',
                                       'co2', 'ph', 'omega_a'),
                            labels = labs)) %>%

  ggplot(aes(datetime, as.numeric(Parameter), group = grp)) +
  geom_line(lwd = 5, color = cbep_colors()[3]) +
  xlab('Date') +
  ylab('') +
  scale_y_continuous(breaks = 1:6, minor_breaks = NULL, labels = labs) +
  theme_minimal() +
  #theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  ggtitle('Data Coverage, 2015-2018') +
  theme(axis.title = element_text(size = 16)) +
  theme(title = element_text(size = 18)) +
  theme(axis.text = element_text(size = 12))
plt
```

## Final Graphic
```{r, fig.height=3, fig.width = 8}
d1 = ISOdate(2015,1,1,tz='America/New_York')
d2 = ISOdate(2018,12,31,tz='America/New_York')
plt + xlim(c(d1,d2))
ggsave('datacoverage.png', width = 7, height = 5, type = 'cairo')
ggsave('datacoverage.pdf', width = 7, height = 5, device = cairo_pdf)
```

# Total Number of Days Each Sensor was Operational

The following code will generate boolean daily flags to show which instruments were in operation for at least a portion of the day.  We can add those up to determine how many days each was operational.
```{r count_operationa}
dt <- as.POSIXlt(coverage$datetime)
tmp <- coverage %>%
  mutate(d = ISOdate(dt$year+1900, dt$mon +1, dt$mday, tz = 'America/New_York')) %>%
  filter(Parameter != 'co2_corr') %>%
  mutate(Parameter = factor(Parameter,
                            levels = c('temp', 'sal', 'do',
                                       'co2', 'ph', 'omega_a'))) %>%
  
  spread(key = Parameter, value = Availability) %>%
  group_by(d) %>%
    summarise(SeaBird = sum(temp, na.rm=TRUE)>0,
              Optode = sum(do, na.rm=TRUE)>0,
              SeaFET = sum(ph, na.rm=TRUE)>0,
              SAMI = sum(co2, na.rm=TRUE)>0,
              Calculations = sum(omega_a, na.rm=TRUE)>0)

```

```{r}
days = sapply(tmp[2:6], sum)
pct = round(100*days/(365*4+1),0)
knitr::kable(rbind(days, pct) )
```